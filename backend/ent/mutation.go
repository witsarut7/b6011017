// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/witsarut7/app/ent/customer"
	"github.com/witsarut7/app/ent/employee"
	"github.com/witsarut7/app/ent/payment"
	"github.com/witsarut7/app/ent/paymenttype"
	"github.com/witsarut7/app/ent/roomtype"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCustomer    = "Customer"
	TypeEmployee    = "Employee"
	TypePayment     = "Payment"
	TypePaymenttype = "Paymenttype"
	TypeRoomtype    = "Roomtype"
)

// CustomerMutation represents an operation that mutate the Customers
// nodes in the graph.
type CustomerMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_USERNAME      *string
	clearedFields  map[string]struct{}
	payment        map[int]struct{}
	removedpayment map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Customer, error)
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows to manage the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for $n.Name.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the id field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUSERNAME sets the USERNAME field.
func (m *CustomerMutation) SetUSERNAME(s string) {
	m._USERNAME = &s
}

// USERNAME returns the USERNAME value in the mutation.
func (m *CustomerMutation) USERNAME() (r string, exists bool) {
	v := m._USERNAME
	if v == nil {
		return
	}
	return *v, true
}

// OldUSERNAME returns the old USERNAME value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldUSERNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUSERNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUSERNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUSERNAME: %w", err)
	}
	return oldValue.USERNAME, nil
}

// ResetUSERNAME reset all changes of the "USERNAME" field.
func (m *CustomerMutation) ResetUSERNAME() {
	m._USERNAME = nil
}

// AddPaymentIDs adds the payment edge to Payment by ids.
func (m *CustomerMutation) AddPaymentIDs(ids ...int) {
	if m.payment == nil {
		m.payment = make(map[int]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payment edge to Payment by ids.
func (m *CustomerMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed ids of payment.
func (m *CustomerMutation) RemovedPaymentIDs() (ids []int) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the payment ids in the mutation.
func (m *CustomerMutation) PaymentIDs() (ids []int) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment reset all changes of the "payment" edge.
func (m *CustomerMutation) ResetPayment() {
	m.payment = nil
	m.removedpayment = nil
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._USERNAME != nil {
		fields = append(fields, customer.FieldUSERNAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldUSERNAME:
		return m.USERNAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldUSERNAME:
		return m.OldUSERNAME(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldUSERNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUSERNAME(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CustomerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldUSERNAME:
		m.ResetUSERNAME()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, customer.EdgePayment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpayment != nil {
		edges = append(edges, customer.EdgePayment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_EMPLOYEENAME     *string
	_EMPLOYEEPASSWORD *string
	clearedFields     map[string]struct{}
	payment           map[int]struct{}
	removedpayment    map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEMPLOYEENAME sets the EMPLOYEENAME field.
func (m *EmployeeMutation) SetEMPLOYEENAME(s string) {
	m._EMPLOYEENAME = &s
}

// EMPLOYEENAME returns the EMPLOYEENAME value in the mutation.
func (m *EmployeeMutation) EMPLOYEENAME() (r string, exists bool) {
	v := m._EMPLOYEENAME
	if v == nil {
		return
	}
	return *v, true
}

// OldEMPLOYEENAME returns the old EMPLOYEENAME value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEMPLOYEENAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEMPLOYEENAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEMPLOYEENAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEMPLOYEENAME: %w", err)
	}
	return oldValue.EMPLOYEENAME, nil
}

// ResetEMPLOYEENAME reset all changes of the "EMPLOYEENAME" field.
func (m *EmployeeMutation) ResetEMPLOYEENAME() {
	m._EMPLOYEENAME = nil
}

// SetEMPLOYEEPASSWORD sets the EMPLOYEEPASSWORD field.
func (m *EmployeeMutation) SetEMPLOYEEPASSWORD(s string) {
	m._EMPLOYEEPASSWORD = &s
}

// EMPLOYEEPASSWORD returns the EMPLOYEEPASSWORD value in the mutation.
func (m *EmployeeMutation) EMPLOYEEPASSWORD() (r string, exists bool) {
	v := m._EMPLOYEEPASSWORD
	if v == nil {
		return
	}
	return *v, true
}

// OldEMPLOYEEPASSWORD returns the old EMPLOYEEPASSWORD value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEMPLOYEEPASSWORD(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEMPLOYEEPASSWORD is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEMPLOYEEPASSWORD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEMPLOYEEPASSWORD: %w", err)
	}
	return oldValue.EMPLOYEEPASSWORD, nil
}

// ResetEMPLOYEEPASSWORD reset all changes of the "EMPLOYEEPASSWORD" field.
func (m *EmployeeMutation) ResetEMPLOYEEPASSWORD() {
	m._EMPLOYEEPASSWORD = nil
}

// AddPaymentIDs adds the payment edge to Payment by ids.
func (m *EmployeeMutation) AddPaymentIDs(ids ...int) {
	if m.payment == nil {
		m.payment = make(map[int]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payment edge to Payment by ids.
func (m *EmployeeMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed ids of payment.
func (m *EmployeeMutation) RemovedPaymentIDs() (ids []int) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the payment ids in the mutation.
func (m *EmployeeMutation) PaymentIDs() (ids []int) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment reset all changes of the "payment" edge.
func (m *EmployeeMutation) ResetPayment() {
	m.payment = nil
	m.removedpayment = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._EMPLOYEENAME != nil {
		fields = append(fields, employee.FieldEMPLOYEENAME)
	}
	if m._EMPLOYEEPASSWORD != nil {
		fields = append(fields, employee.FieldEMPLOYEEPASSWORD)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEMPLOYEENAME:
		return m.EMPLOYEENAME()
	case employee.FieldEMPLOYEEPASSWORD:
		return m.EMPLOYEEPASSWORD()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldEMPLOYEENAME:
		return m.OldEMPLOYEENAME(ctx)
	case employee.FieldEMPLOYEEPASSWORD:
		return m.OldEMPLOYEEPASSWORD(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEMPLOYEENAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEMPLOYEENAME(v)
		return nil
	case employee.FieldEMPLOYEEPASSWORD:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEMPLOYEEPASSWORD(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldEMPLOYEENAME:
		m.ResetEMPLOYEENAME()
		return nil
	case employee.FieldEMPLOYEEPASSWORD:
		m.ResetEMPLOYEEPASSWORD()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, employee.EdgePayment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpayment != nil {
		edges = append(edges, employee.EdgePayment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// PaymentMutation represents an operation that mutate the Payments
// nodes in the graph.
type PaymentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_PAYDAY            *time.Time
	clearedFields      map[string]struct{}
	customer           *int
	clearedcustomer    bool
	employee           *int
	clearedemployee    bool
	paymenttype        *int
	clearedpaymenttype bool
	roomtype           *int
	clearedroomtype    bool
	done               bool
	oldValue           func(context.Context) (*Payment, error)
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows to manage the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for $n.Name.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the id field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPAYDAY sets the PAYDAY field.
func (m *PaymentMutation) SetPAYDAY(t time.Time) {
	m._PAYDAY = &t
}

// PAYDAY returns the PAYDAY value in the mutation.
func (m *PaymentMutation) PAYDAY() (r time.Time, exists bool) {
	v := m._PAYDAY
	if v == nil {
		return
	}
	return *v, true
}

// OldPAYDAY returns the old PAYDAY value of the Payment.
// If the Payment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymentMutation) OldPAYDAY(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPAYDAY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPAYDAY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPAYDAY: %w", err)
	}
	return oldValue.PAYDAY, nil
}

// ResetPAYDAY reset all changes of the "PAYDAY" field.
func (m *PaymentMutation) ResetPAYDAY() {
	m._PAYDAY = nil
}

// SetCustomerID sets the customer edge to Customer by id.
func (m *PaymentMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the customer edge to Customer.
func (m *PaymentMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared returns if the edge customer was cleared.
func (m *PaymentMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the customer id in the mutation.
func (m *PaymentMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the customer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer reset all changes of the "customer" edge.
func (m *PaymentMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *PaymentMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *PaymentMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *PaymentMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *PaymentMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *PaymentMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetPaymenttypeID sets the paymenttype edge to Paymenttype by id.
func (m *PaymentMutation) SetPaymenttypeID(id int) {
	m.paymenttype = &id
}

// ClearPaymenttype clears the paymenttype edge to Paymenttype.
func (m *PaymentMutation) ClearPaymenttype() {
	m.clearedpaymenttype = true
}

// PaymenttypeCleared returns if the edge paymenttype was cleared.
func (m *PaymentMutation) PaymenttypeCleared() bool {
	return m.clearedpaymenttype
}

// PaymenttypeID returns the paymenttype id in the mutation.
func (m *PaymentMutation) PaymenttypeID() (id int, exists bool) {
	if m.paymenttype != nil {
		return *m.paymenttype, true
	}
	return
}

// PaymenttypeIDs returns the paymenttype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PaymenttypeID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) PaymenttypeIDs() (ids []int) {
	if id := m.paymenttype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymenttype reset all changes of the "paymenttype" edge.
func (m *PaymentMutation) ResetPaymenttype() {
	m.paymenttype = nil
	m.clearedpaymenttype = false
}

// SetRoomtypeID sets the roomtype edge to Roomtype by id.
func (m *PaymentMutation) SetRoomtypeID(id int) {
	m.roomtype = &id
}

// ClearRoomtype clears the roomtype edge to Roomtype.
func (m *PaymentMutation) ClearRoomtype() {
	m.clearedroomtype = true
}

// RoomtypeCleared returns if the edge roomtype was cleared.
func (m *PaymentMutation) RoomtypeCleared() bool {
	return m.clearedroomtype
}

// RoomtypeID returns the roomtype id in the mutation.
func (m *PaymentMutation) RoomtypeID() (id int, exists bool) {
	if m.roomtype != nil {
		return *m.roomtype, true
	}
	return
}

// RoomtypeIDs returns the roomtype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomtypeID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) RoomtypeIDs() (ids []int) {
	if id := m.roomtype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomtype reset all changes of the "roomtype" edge.
func (m *PaymentMutation) ResetRoomtype() {
	m.roomtype = nil
	m.clearedroomtype = false
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._PAYDAY != nil {
		fields = append(fields, payment.FieldPAYDAY)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldPAYDAY:
		return m.PAYDAY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldPAYDAY:
		return m.OldPAYDAY(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldPAYDAY:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPAYDAY(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldPAYDAY:
		m.ResetPAYDAY()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.customer != nil {
		edges = append(edges, payment.EdgeCustomer)
	}
	if m.employee != nil {
		edges = append(edges, payment.EdgeEmployee)
	}
	if m.paymenttype != nil {
		edges = append(edges, payment.EdgePaymenttype)
	}
	if m.roomtype != nil {
		edges = append(edges, payment.EdgeRoomtype)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgePaymenttype:
		if id := m.paymenttype; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgeRoomtype:
		if id := m.roomtype; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcustomer {
		edges = append(edges, payment.EdgeCustomer)
	}
	if m.clearedemployee {
		edges = append(edges, payment.EdgeEmployee)
	}
	if m.clearedpaymenttype {
		edges = append(edges, payment.EdgePaymenttype)
	}
	if m.clearedroomtype {
		edges = append(edges, payment.EdgeRoomtype)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeCustomer:
		return m.clearedcustomer
	case payment.EdgeEmployee:
		return m.clearedemployee
	case payment.EdgePaymenttype:
		return m.clearedpaymenttype
	case payment.EdgeRoomtype:
		return m.clearedroomtype
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case payment.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case payment.EdgePaymenttype:
		m.ClearPaymenttype()
		return nil
	case payment.EdgeRoomtype:
		m.ClearRoomtype()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case payment.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case payment.EdgePaymenttype:
		m.ResetPaymenttype()
		return nil
	case payment.EdgeRoomtype:
		m.ResetRoomtype()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PaymenttypeMutation represents an operation that mutate the Paymenttypes
// nodes in the graph.
type PaymenttypeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_TYPE          *string
	clearedFields  map[string]struct{}
	payment        map[int]struct{}
	removedpayment map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Paymenttype, error)
}

var _ ent.Mutation = (*PaymenttypeMutation)(nil)

// paymenttypeOption allows to manage the mutation configuration using functional options.
type paymenttypeOption func(*PaymenttypeMutation)

// newPaymenttypeMutation creates new mutation for $n.Name.
func newPaymenttypeMutation(c config, op Op, opts ...paymenttypeOption) *PaymenttypeMutation {
	m := &PaymenttypeMutation{
		config:        c,
		op:            op,
		typ:           TypePaymenttype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymenttypeID sets the id field of the mutation.
func withPaymenttypeID(id int) paymenttypeOption {
	return func(m *PaymenttypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Paymenttype
		)
		m.oldValue = func(ctx context.Context) (*Paymenttype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Paymenttype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymenttype sets the old Paymenttype of the mutation.
func withPaymenttype(node *Paymenttype) paymenttypeOption {
	return func(m *PaymenttypeMutation) {
		m.oldValue = func(context.Context) (*Paymenttype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymenttypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymenttypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaymenttypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTYPE sets the TYPE field.
func (m *PaymenttypeMutation) SetTYPE(s string) {
	m._TYPE = &s
}

// TYPE returns the TYPE value in the mutation.
func (m *PaymenttypeMutation) TYPE() (r string, exists bool) {
	v := m._TYPE
	if v == nil {
		return
	}
	return *v, true
}

// OldTYPE returns the old TYPE value of the Paymenttype.
// If the Paymenttype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymenttypeMutation) OldTYPE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTYPE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTYPE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTYPE: %w", err)
	}
	return oldValue.TYPE, nil
}

// ResetTYPE reset all changes of the "TYPE" field.
func (m *PaymenttypeMutation) ResetTYPE() {
	m._TYPE = nil
}

// AddPaymentIDs adds the payment edge to Payment by ids.
func (m *PaymenttypeMutation) AddPaymentIDs(ids ...int) {
	if m.payment == nil {
		m.payment = make(map[int]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payment edge to Payment by ids.
func (m *PaymenttypeMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed ids of payment.
func (m *PaymenttypeMutation) RemovedPaymentIDs() (ids []int) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the payment ids in the mutation.
func (m *PaymenttypeMutation) PaymentIDs() (ids []int) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment reset all changes of the "payment" edge.
func (m *PaymenttypeMutation) ResetPayment() {
	m.payment = nil
	m.removedpayment = nil
}

// Op returns the operation name.
func (m *PaymenttypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Paymenttype).
func (m *PaymenttypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaymenttypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TYPE != nil {
		fields = append(fields, paymenttype.FieldTYPE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaymenttypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymenttype.FieldTYPE:
		return m.TYPE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaymenttypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymenttype.FieldTYPE:
		return m.OldTYPE(ctx)
	}
	return nil, fmt.Errorf("unknown Paymenttype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymenttypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymenttype.FieldTYPE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTYPE(v)
		return nil
	}
	return fmt.Errorf("unknown Paymenttype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaymenttypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaymenttypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymenttypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Paymenttype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaymenttypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaymenttypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymenttypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Paymenttype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaymenttypeMutation) ResetField(name string) error {
	switch name {
	case paymenttype.FieldTYPE:
		m.ResetTYPE()
		return nil
	}
	return fmt.Errorf("unknown Paymenttype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaymenttypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, paymenttype.EdgePayment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaymenttypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymenttype.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaymenttypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpayment != nil {
		edges = append(edges, paymenttype.EdgePayment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaymenttypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paymenttype.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaymenttypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaymenttypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaymenttypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Paymenttype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaymenttypeMutation) ResetEdge(name string) error {
	switch name {
	case paymenttype.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown Paymenttype edge %s", name)
}

// RoomtypeMutation represents an operation that mutate the Roomtypes
// nodes in the graph.
type RoomtypeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_ROOMPRICE     *int
	add_ROOMPRICE  *int
	clearedFields  map[string]struct{}
	payment        map[int]struct{}
	removedpayment map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Roomtype, error)
}

var _ ent.Mutation = (*RoomtypeMutation)(nil)

// roomtypeOption allows to manage the mutation configuration using functional options.
type roomtypeOption func(*RoomtypeMutation)

// newRoomtypeMutation creates new mutation for $n.Name.
func newRoomtypeMutation(c config, op Op, opts ...roomtypeOption) *RoomtypeMutation {
	m := &RoomtypeMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomtype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomtypeID sets the id field of the mutation.
func withRoomtypeID(id int) roomtypeOption {
	return func(m *RoomtypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Roomtype
		)
		m.oldValue = func(ctx context.Context) (*Roomtype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Roomtype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomtype sets the old Roomtype of the mutation.
func withRoomtype(node *Roomtype) roomtypeOption {
	return func(m *RoomtypeMutation) {
		m.oldValue = func(context.Context) (*Roomtype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomtypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomtypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomtypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetROOMPRICE sets the ROOMPRICE field.
func (m *RoomtypeMutation) SetROOMPRICE(i int) {
	m._ROOMPRICE = &i
	m.add_ROOMPRICE = nil
}

// ROOMPRICE returns the ROOMPRICE value in the mutation.
func (m *RoomtypeMutation) ROOMPRICE() (r int, exists bool) {
	v := m._ROOMPRICE
	if v == nil {
		return
	}
	return *v, true
}

// OldROOMPRICE returns the old ROOMPRICE value of the Roomtype.
// If the Roomtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomtypeMutation) OldROOMPRICE(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldROOMPRICE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldROOMPRICE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldROOMPRICE: %w", err)
	}
	return oldValue.ROOMPRICE, nil
}

// AddROOMPRICE adds i to ROOMPRICE.
func (m *RoomtypeMutation) AddROOMPRICE(i int) {
	if m.add_ROOMPRICE != nil {
		*m.add_ROOMPRICE += i
	} else {
		m.add_ROOMPRICE = &i
	}
}

// AddedROOMPRICE returns the value that was added to the ROOMPRICE field in this mutation.
func (m *RoomtypeMutation) AddedROOMPRICE() (r int, exists bool) {
	v := m.add_ROOMPRICE
	if v == nil {
		return
	}
	return *v, true
}

// ResetROOMPRICE reset all changes of the "ROOMPRICE" field.
func (m *RoomtypeMutation) ResetROOMPRICE() {
	m._ROOMPRICE = nil
	m.add_ROOMPRICE = nil
}

// AddPaymentIDs adds the payment edge to Payment by ids.
func (m *RoomtypeMutation) AddPaymentIDs(ids ...int) {
	if m.payment == nil {
		m.payment = make(map[int]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// RemovePaymentIDs removes the payment edge to Payment by ids.
func (m *RoomtypeMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed ids of payment.
func (m *RoomtypeMutation) RemovedPaymentIDs() (ids []int) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the payment ids in the mutation.
func (m *RoomtypeMutation) PaymentIDs() (ids []int) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment reset all changes of the "payment" edge.
func (m *RoomtypeMutation) ResetPayment() {
	m.payment = nil
	m.removedpayment = nil
}

// Op returns the operation name.
func (m *RoomtypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Roomtype).
func (m *RoomtypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomtypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._ROOMPRICE != nil {
		fields = append(fields, roomtype.FieldROOMPRICE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomtypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomtype.FieldROOMPRICE:
		return m.ROOMPRICE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomtypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomtype.FieldROOMPRICE:
		return m.OldROOMPRICE(ctx)
	}
	return nil, fmt.Errorf("unknown Roomtype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomtypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomtype.FieldROOMPRICE:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetROOMPRICE(v)
		return nil
	}
	return fmt.Errorf("unknown Roomtype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomtypeMutation) AddedFields() []string {
	var fields []string
	if m.add_ROOMPRICE != nil {
		fields = append(fields, roomtype.FieldROOMPRICE)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomtypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case roomtype.FieldROOMPRICE:
		return m.AddedROOMPRICE()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomtypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case roomtype.FieldROOMPRICE:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddROOMPRICE(v)
		return nil
	}
	return fmt.Errorf("unknown Roomtype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomtypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomtypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomtypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Roomtype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomtypeMutation) ResetField(name string) error {
	switch name {
	case roomtype.FieldROOMPRICE:
		m.ResetROOMPRICE()
		return nil
	}
	return fmt.Errorf("unknown Roomtype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomtypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, roomtype.EdgePayment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomtypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roomtype.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomtypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpayment != nil {
		edges = append(edges, roomtype.EdgePayment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomtypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case roomtype.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomtypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomtypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomtypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Roomtype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomtypeMutation) ResetEdge(name string) error {
	switch name {
	case roomtype.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown Roomtype edge %s", name)
}
